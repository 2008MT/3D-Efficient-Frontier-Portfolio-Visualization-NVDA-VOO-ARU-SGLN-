import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable
import warnings
from datetime import datetime, timedelta
from scipy.optimize import minimize

# Use only yfinance for data fetching
try:
    import yfinance as yf
except ImportError:
    raise ImportError("yfinance is required to fetch real-world data. Please install it using: pip install yfinance")

warnings.filterwarnings('ignore')

class EfficientSurface3D:
    def __init__(self, tickers, start_date=None, end_date=None):
        """
        Initialize the 3D Efficient Surface visualization
        
        Parameters:
        tickers (list): List of ticker symbols
        start_date (str): Start date for data retrieval (YYYY-MM-DD)
        end_date (str): End date for data retrieval (YYYY-MM-DD)
        """
        self.tickers = tickers
        self.start_date = start_date or (datetime.now() - timedelta(days=10*365)).strftime('%Y-%m-%d')
        self.end_date = end_date or datetime.now().strftime('%Y-%m-%d')
        self.data = None
        self.returns = None
        self.mean_returns = None
        self.cov_matrix = None
        
    def fetch_data_yfinance(self):
        """Fetch data using yfinance (with error handling)"""
        print("Attempting to fetch data from Yahoo Finance...")
        
        # Try different ticker formats for international stocks
        ticker_variants = {
            'NVDA': ['NVDA'],
            'VOO': ['VOO', 'VUAA.L', 'VUAA'],  # Try VOO first, then alternatives
            'ARU': ['ARU.AX', 'ARU'],
            'SGLN': ['SGLN.L', 'IAU', 'GLD']  # Try London listing, then alternatives
        }
        
        final_tickers = []
        for original_ticker in self.tickers:
            success = False
            for variant in ticker_variants.get(original_ticker, [original_ticker]):
                try:
                    test_data = yf.download(variant, start=self.start_date, end=self.end_date, progress=False)
                    if not test_data.empty and len(test_data) > 100:  # Ensure we have sufficient data
                        final_tickers.append(variant)
                        print(f"  ✓ {original_ticker} -> {variant}: {len(test_data)} days")
                        success = True
                        break
                except Exception:
                    continue
            
            if not success:
                raise ValueError(f"Could not fetch data for ticker {original_ticker}. Please check the ticker symbol or availability.")
        
        # Download all data at once
        data = yf.download(final_tickers, start=self.start_date, end=self.end_date, progress=False)
        
        if len(final_tickers) == 1:
            self.data = pd.DataFrame(data['Close'])
            self.data.columns = final_tickers
        else:
            self.data = data['Close']
            
        # Rename columns to original tickers for consistency
        column_mapping = dict(zip(final_tickers, self.tickers))
        self.data = self.data.rename(columns=column_mapping)
        self.data = self.data[self.tickers]  # <-- Ensure column order matches tickers
        
        # Clean data
        self.data = self.data.dropna()
        
        if len(self.data) < 100:
            raise ValueError("Insufficient data points returned. Try a wider date range or check ticker validity.")
            
        print(f"Successfully fetched data: {len(self.data)} trading days")
        return True
    
    def fetch_data(self):
        """Main data fetching method"""
        self.fetch_data_yfinance()
        
        # Calculate returns and statistics
        self.returns = self.data.pct_change().dropna()
        self.mean_returns = self.returns.mean() * 252  # Annualized
        self.cov_matrix = self.returns.cov() * 252     # Annualized
        
        print("\nAsset Statistics (Annualized):")
        print("-" * 40)
        for ticker in self.tickers:
            ret = self.mean_returns[ticker]
            vol = np.sqrt(self.cov_matrix.loc[ticker, ticker])
            print(f"{ticker:>6}: Return {ret:>7.1%}, Volatility {vol:>6.1%}")
    
    def portfolio_metrics(self, weights):
        """Calculate portfolio return and volatility"""
        portfolio_return = np.sum(weights * self.mean_returns)
        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
        return portfolio_return, portfolio_volatility
    
    def generate_efficient_surface_data(self, n_points=20):
        """
        Generate data points for the 3D efficient surface
        
        Parameters:
        n_points (int): Number of points along each axis
        
        Returns:
        dict: Contains coordinate arrays and portfolio metrics
        """
        print(f"\nGenerating efficient surface data ({n_points}³ combinations)...")
        
        # Create weight ranges (ensure they don't exceed 1)
        weight_step = 1.0 / (n_points - 1)
        weight_range = np.linspace(0, 1, n_points)
        
        valid_combinations = []
        total_combinations = 0
        
        for nvda_w in weight_range:
            for voo_w in weight_range:
                for aru_w in weight_range:
                    total_combinations += 1
                    
                    # Calculate SGLN weight
                    sgln_w = 1 - nvda_w - voo_w - aru_w
                    
                    # Check if weights are valid (all non-negative and sum to 1)
                    if sgln_w >= 0 and sgln_w <= 1:
                        weights = np.array([nvda_w, voo_w, aru_w, sgln_w])
                        ret, vol = self.portfolio_metrics(weights)
                        
                        # Only include portfolios with reasonable risk/return profiles
                        if vol > 0 and ret > -0.5:  # Filter out extreme negative returns
                            valid_combinations.append({
                                'nvda_weight': nvda_w,
                                'voo_weight': voo_w,
                                'aru_weight': aru_w,
                                'sgln_weight': sgln_w,
                                'return': ret,
                                'volatility': vol,
                                'sharpe': ret / vol if vol > 0 else -999
                            })
        
        print(f"Generated {len(valid_combinations)} valid portfolios from {total_combinations} combinations")
        print(f"Efficiency: {len(valid_combinations)/total_combinations:.1%}")
        
        return valid_combinations
    
    def create_3d_visualization(self, portfolio_data, figsize=(16, 12)):
        """Create the 3D visualization with color and shape coding"""
        
        if not portfolio_data:
            raise ValueError("No valid portfolio data to visualize")
        
        # Convert to arrays for plotting
        nvda_weights = np.array([p['nvda_weight'] for p in portfolio_data])
        voo_weights = np.array([p['voo_weight'] for p in portfolio_data])
        aru_weights = np.array([p['aru_weight'] for p in portfolio_data])
        returns = np.array([p['return'] for p in portfolio_data])
        volatilities = np.array([p['volatility'] for p in portfolio_data])
        
        print(f"\nVisualization Statistics:")
        print(f"Return range: {returns.min():.1%} to {returns.max():.1%}")
        print(f"Volatility range: {volatilities.min():.1%} to {volatilities.max():.1%}")
        
        # Create the figure
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection='3d')
        
        # Normalize returns and volatilities for color and marker mapping
        norm_returns = Normalize(vmin=returns.min(), vmax=returns.max())
        norm_volatilities = Normalize(vmin=volatilities.min(), vmax=volatilities.max())
        
        # Define marker styles for different volatility levels
        markers = ['o', 's', '^', 'v', 'D', 'p', '*', 'h', 'P', 'X']
        n_vol_bins = min(len(markers), 8)  # Limit number of bins for clarity
        vol_bins = np.linspace(volatilities.min(), volatilities.max(), n_vol_bins + 1)
        
        # Create scatter plot with reduced number of points for performance
        # n_points = len(portfolio_data)
        # if n_points > 100000:  # Subsample if too many points
            # indices = np.random.choice(n_points, 100000, replace=False)
            # nvda_weights = nvda_weights[indices]
            # voo_weights = voo_weights[indices]
            # aru_weights = aru_weights[indices]
            # returns = returns[indices]
            # volatilities = volatilities[indices]
            # print(f"Subsampled to 100000 points for better performance")
        
        # Group points by volatility bin for efficient plotting
        for vol_bin_idx in range(n_vol_bins):
            vol_mask = (volatilities >= vol_bins[vol_bin_idx]) & (volatilities < vol_bins[vol_bin_idx + 1])
            if vol_bin_idx == n_vol_bins - 1:  # Include the maximum value in the last bin
                vol_mask = (volatilities >= vol_bins[vol_bin_idx]) & (volatilities <= vol_bins[vol_bin_idx + 1])
            
            if np.any(vol_mask):
                marker = markers[vol_bin_idx % len(markers)]
                ax.scatter(nvda_weights[vol_mask], voo_weights[vol_mask], aru_weights[vol_mask],
                          c=returns[vol_mask], cmap='viridis', 
                          marker=marker, s=30, alpha=0.7,
                          vmin=returns.min(), vmax=returns.max())
        
        # Set labels and title
        ax.set_xlabel('NVDA Weight', fontsize=12, labelpad=10)
        ax.set_ylabel('VOO Weight', fontsize=12, labelpad=10)
        ax.set_zlabel('ARU Weight', fontsize=12, labelpad=10)
        ax.set_title('3D Efficient Surface: 4-Asset Portfolio\n(NVDA, VOO, ARU, SGLN)', 
                    fontsize=14, pad=20)
        
        # Add color bar for returns (left side)
        cbar_ax1 = fig.add_axes([0.02, 0.15, 0.03, 0.7])
        sm_returns = ScalarMappable(norm=norm_returns, cmap='viridis')
        sm_returns.set_array([])
        cbar1 = fig.colorbar(sm_returns, cax=cbar_ax1)
        cbar1.set_label('Expected Annual Return', rotation=90, labelpad=15, fontsize=10)
        
        # Format colorbar labels as percentages
        cbar1_ticks = cbar1.get_ticks()
        cbar1.set_ticklabels([f'{tick:.1%}' for tick in cbar1_ticks])
        
        # Add shape legend for volatility (right side)
        legend_elements = []
        for i in range(n_vol_bins):
            vol_range_min = vol_bins[i]
            vol_range_max = vol_bins[i + 1]
            label = f'{vol_range_min:.1%} - {vol_range_max:.1%}'
            marker = markers[i % len(markers)]
            legend_elements.append(plt.Line2D([0], [0], marker=marker, color='gray', 
                                           linestyle='None', markersize=8, label=label))
        
        # Position legend on the right
        legend = ax.legend(handles=legend_elements, title='Portfolio Risk\n(Annual Volatility)', 
                          bbox_to_anchor=(1.15, 1), loc='upper left', fontsize=9)
        legend.get_title().set_fontsize(10)
        
        # Optimize viewing angle
        ax.view_init(elev=20, azim=45)
        
        # Add grid
        ax.grid(True, alpha=0.3)
        
        # Set axis limits to [0, 1] for weights
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_zlim(0, 1)
        
        # Add text box with portfolio info
        textstr = f'''Portfolio Analysis Summary:
• Data Period: {len(self.data)} trading days
• Valid Combinations: {len(portfolio_data):,}
• Return Range: {returns.min():.1%} to {returns.max():.1%}
• Risk Range: {volatilities.min():.1%} to {volatilities.max():.1%}

Weight Constraints:
• NVDA + VOO + ARU + SGLN = 100%
• All weights ≥ 0%'''
        
        props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
        ax.text2D(0.02, 0.98, textstr, transform=ax.transAxes, fontsize=9,
                 verticalalignment='top', bbox=props)
        
        plt.tight_layout()
        return fig, ax
    
    def find_optimal_portfolios(self, portfolio_data):
        """Find key optimal portfolios"""
        if not portfolio_data:
            return {}
            
        df = pd.DataFrame(portfolio_data)
        
        # Find portfolios with specific characteristics
        min_vol_idx = df['volatility'].idxmin()
        max_return_idx = df['return'].idxmax()
        max_sharpe_idx = df['sharpe'].idxmax()
        
        # Find balanced portfolios
        df['balance_score'] = 1 / (df[['nvda_weight', 'voo_weight', 'aru_weight', 'sgln_weight']].var(axis=1) + 0.01)
        max_balance_idx = df['balance_score'].idxmax()
        
        optimal_portfolios = {
            'Minimum Volatility': df.iloc[min_vol_idx],
            'Maximum Return': df.iloc[max_return_idx],
            'Maximum Sharpe Ratio': df.iloc[max_sharpe_idx],
            'Most Balanced': df.iloc[max_balance_idx]
        }
        
        print("\n" + "="*70)
        print("OPTIMAL PORTFOLIO ANALYSIS")
        print("="*70)
        
        for name, portfolio in optimal_portfolios.items():
            print(f"\n{name}:")
            print(f"  NVDA: {portfolio['nvda_weight']:>6.1%}  |  VOO: {portfolio['voo_weight']:>6.1%}")
            print(f"  ARU:  {portfolio['aru_weight']:>6.1%}  |  SGLN: {portfolio['sgln_weight']:>6.1%}")
            print(f"  Expected Return: {portfolio['return']:>6.2%}  |  Volatility: {portfolio['volatility']:>6.2%}")
            print(f"  Sharpe Ratio: {portfolio['sharpe']:>6.3f}")
        
        return optimal_portfolios

def main():
    # Define the portfolio tickers
    tickers = ['NVDA', 'VOO', 'ARU', 'SGLN']
    
    print("="*70)
    print("3D EFFICIENT SURFACE PORTFOLIO ANALYSIS")
    print("Modern Portfolio Theory Visualization")
    print("="*70)
    
    # Initialize the analyzer
    analyzer = EfficientSurface3D(tickers)
    
    try:
        # Fetch data
        analyzer.fetch_data()
        
        # Generate efficient surface data (reduced points for performance)
        portfolio_data = analyzer.generate_efficient_surface_data(n_points=100)
        
        if not portfolio_data:
            print("No valid portfolio combinations found!")
            return
        
        # Create visualization
        print("\nCreating 3D visualization...")
        fig, ax = analyzer.create_3d_visualization(portfolio_data)
        
        # Find optimal portfolios
        optimal_portfolios = analyzer.find_optimal_portfolios(portfolio_data)
        
        # Show the plot
        plt.show()
        
    except Exception as e:
        print(f"\nError in analysis: {e}")
        print("\nTroubleshooting tips:")
        print("1. Ensure you have required packages: matplotlib, numpy, pandas, scipy, yfinance")
        print("2. For live data, install: pip install yfinance")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
