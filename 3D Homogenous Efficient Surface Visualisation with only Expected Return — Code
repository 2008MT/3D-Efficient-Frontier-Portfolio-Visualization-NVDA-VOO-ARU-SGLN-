import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable
import warnings
from datetime import datetime, timedelta
import yfinance as yf

warnings.filterwarnings('ignore')

class EfficientSurface3D:
    def __init__(self, tickers, start_date=None, end_date=None):
        self.tickers = tickers
        self.start_date = start_date or (datetime.now() - timedelta(days=10*365)).strftime('%Y-%m-%d')
        self.end_date = end_date or datetime.now().strftime('%Y-%m-%d')
        self.data = None
        self.returns = None
        self.mean_returns = None
        self.cov_matrix = None
        
    def fetch_data(self):
        print("Fetching data from Yahoo Finance...")
        ticker_variants = {
            'NVDA': ['NVDA'],
            'VOO': ['VOO', 'VUAA.L', 'VUAA'],
            'ARU': ['ARU.AX', 'ARU'],
            'SGLN': ['SGLN.L', 'IAU', 'GLD']
        }
        final_tickers = []
        for original_ticker in self.tickers:
            success = False
            for variant in ticker_variants.get(original_ticker, [original_ticker]):
                try:
                    test_data = yf.download(variant, start=self.start_date, end=self.end_date, progress=False)
                    if not test_data.empty and len(test_data) > 100:
                        final_tickers.append(variant)
                        print(f"  ✓ {original_ticker} -> {variant}: {len(test_data)} days")
                        success = True
                        break
                except Exception:
                    continue
            if not success:
                raise ValueError(f"Could not fetch data for ticker {original_ticker}.")
        data = yf.download(final_tickers, start=self.start_date, end=self.end_date, progress=False)
        if len(final_tickers) == 1:
            self.data = pd.DataFrame(data['Close'])
            self.data.columns = final_tickers
        else:
            self.data = data['Close']
        column_mapping = dict(zip(final_tickers, self.tickers))
        self.data = self.data.rename(columns=column_mapping)
        self.data = self.data[self.tickers]
        self.data = self.data.dropna()
        if len(self.data) < 100:
            raise ValueError("Insufficient data points returned.")
        print(f"Data fetched: {len(self.data)} trading days")
        self.returns = self.data.pct_change().dropna()
        self.mean_returns = self.returns.mean() * 252
        self.cov_matrix = self.returns.cov() * 252
        print("\nAsset Statistics (Annualized):")
        print("-" * 40)
        for ticker in self.tickers:
            ret = self.mean_returns[ticker]
            vol = np.sqrt(self.cov_matrix.loc[ticker, ticker])
            print(f"{ticker:>6}: Return {ret:>7.1%}, Volatility {vol:>6.1%}")

    def portfolio_metrics(self, weights):
        portfolio_return = np.sum(weights * self.mean_returns)
        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
        return portfolio_return, portfolio_volatility

    def generate_grid_surface(self, n_points=100):
        # Uniform grid for NVDA, VOO, ARU, with SGLN = 1 - sum
        print(f"\nGenerating efficient surface data ({n_points}³ combinations)...")
        weight_range = np.linspace(0, 1, n_points)
        nvda_w, voo_w, aru_w = np.meshgrid(weight_range, weight_range, weight_range)
        nvda_w = nvda_w.flatten()
        voo_w = voo_w.flatten()
        aru_w = aru_w.flatten()
        sgln_w = 1 - nvda_w - voo_w - aru_w
        valid = (sgln_w >= 0) & (sgln_w <= 1)
        nvda_w = nvda_w[valid]
        voo_w = voo_w[valid]
        aru_w = aru_w[valid]
        sgln_w = sgln_w[valid]
        weights = np.vstack([nvda_w, voo_w, aru_w, sgln_w]).T
        returns = []
        volatilities = []
        sharpes = []
        for w in weights:
            ret, vol = self.portfolio_metrics(w)
            returns.append(ret)
            volatilities.append(vol)
            sharpes.append(ret/vol if vol > 0 else -999)
        returns = np.array(returns)
        volatilities = np.array(volatilities)
        sharpes = np.array(sharpes)
        print(f"Generated {len(returns)} valid portfolios from {n_points ** 3} combinations")
        print(f"Efficiency: {len(returns) / (n_points ** 3):.1%}")
        return nvda_w, voo_w, aru_w, sgln_w, returns, volatilities, sharpes

    def plot_homogeneous_surface(self, nvda_w, voo_w, aru_w, returns, figsize=(12, 10)):
        print("\nCreating homogeneous 3D surface visualization...")
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection='3d')
        norm = Normalize(vmin=returns.min(), vmax=returns.max())
        surf = ax.plot_trisurf(nvda_w, voo_w, aru_w, cmap='viridis',
                               linewidth=0.2, antialiased=True,
                               shade=True, alpha=0.95,
                               facecolors=plt.cm.viridis(norm(returns)))
        mappable = ScalarMappable(cmap='viridis', norm=norm)
        mappable.set_array(returns)
        cbar = fig.colorbar(mappable, ax=ax, shrink=0.65, pad=0.15)
        cbar.set_label('Expected Annual Return', fontsize=12)
        cbar.set_ticks(np.linspace(returns.min(), returns.max(), 7))
        cbar.set_ticklabels([f'{tick:.1%}' for tick in np.linspace(returns.min(), returns.max(), 7)])
        ax.set_xlabel('NVDA Weight', fontsize=12)
        ax.set_ylabel('VOO Weight', fontsize=12)
        ax.set_zlabel('ARU Weight', fontsize=12)
        ax.set_title('3D Efficient Surface (Return Only)\nHomogeneous Representation', fontsize=14)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_zlim(0, 1)
        ax.view_init(elev=30, azim=45)
        ax.grid(False)
        plt.tight_layout()
        return fig, ax

    def find_optimal_portfolios(self, nvda_w, voo_w, aru_w, sgln_w, returns, volatilities, sharpes):
        # Make a DataFrame for easy indexing
        df = pd.DataFrame({
            'nvda_weight': nvda_w,
            'voo_weight': voo_w,
            'aru_weight': aru_w,
            'sgln_weight': sgln_w,
            'return': returns,
            'volatility': volatilities,
            'sharpe': sharpes
        })
        # Minimum Volatility Portfolio
        min_vol_idx = df['volatility'].idxmin()
        # Maximum Return Portfolio
        max_return_idx = df['return'].idxmax()
        # Maximum Sharpe Ratio Portfolio
        max_sharpe_idx = df['sharpe'].idxmax()
        # Most Balanced Portfolio (least variance among weights)
        df['balance_score'] = 1 / (df[['nvda_weight', 'voo_weight', 'aru_weight', 'sgln_weight']].var(axis=1) + 0.01)
        max_balance_idx = df['balance_score'].idxmax()
        optimal_portfolios = {
            'Minimum Volatility': df.iloc[min_vol_idx],
            'Maximum Return': df.iloc[max_return_idx],
            'Maximum Sharpe Ratio': df.iloc[max_sharpe_idx],
            'Most Balanced': df.iloc[max_balance_idx]
        }
        print("\n" + "="*70)
        print("OPTIMAL PORTFOLIO ANALYSIS")
        print("="*70)
        for name, portfolio in optimal_portfolios.items():
            print(f"\n{name}:")
            print(f"  NVDA: {portfolio['nvda_weight']:>6.1%}  |  VOO: {portfolio['voo_weight']:>6.1%}")
            print(f"  ARU:  {portfolio['aru_weight']:>6.1%}  |  SGLN: {portfolio['sgln_weight']:>6.1%}")
            print(f"  Expected Return: {portfolio['return']:>6.2%}  |  Volatility: {portfolio['volatility']:>6.2%}")
            print(f"  Sharpe Ratio: {portfolio['sharpe']:>6.3f}")
        return optimal_portfolios

def main():
    tickers = ['NVDA', 'VOO', 'ARU', 'SGLN']
    print("="*70)
    print("3D EFFICIENT SURFACE PORTFOLIO ANALYSIS")
    print("Modern Portfolio Theory Visualization")
    print("="*70)
    analyzer = EfficientSurface3D(tickers)
    try:
        analyzer.fetch_data()
        nvda_w, voo_w, aru_w, sgln_w, returns, volatilities, sharpes = analyzer.generate_grid_surface(n_points=100)
        print("\nVisualization Statistics:")
        print(f"Return range: {returns.min():.1%} to {returns.max():.1%}")
        print(f"Volatility range: {volatilities.min():.1%} to {volatilities.max():.1%}")
        analyzer.find_optimal_portfolios(nvda_w, voo_w, aru_w, sgln_w, returns, volatilities, sharpes)
        fig, ax = analyzer.plot_homogeneous_surface(nvda_w, voo_w, aru_w, returns)
        plt.show()
        try:
            fig.savefig('efficient_surface_3d_homogeneous.png', dpi=300, bbox_inches='tight')
            print(f"\n✓ Visualization saved as 'efficient_surface_3d_homogeneous.png'")
        except Exception as e:
            print(f"Could not save figure: {e}")
        print("\n" + "="*70)
        print("ANALYSIS COMPLETE")
        print("="*70)
    except Exception as e:
        print(f"\nError in analysis: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
